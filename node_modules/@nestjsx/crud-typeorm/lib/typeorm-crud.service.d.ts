import { CreateManyDto, CrudRequest, CrudRequestOptions, CrudService, GetManyDefaultResponse, JoinOptions, QueryOptions } from '@nestjsx/crud';
import { ParsedRequestParams, QueryFilter, QueryJoin, QuerySort, SCondition, SConditionKey, ComparisonOperator } from '@nestjsx/crud-request';
import { ClassType } from 'class-transformer/ClassTransformer';
import { Brackets, ObjectLiteral, Repository, SelectQueryBuilder, DeepPartial, WhereExpression, ConnectionOptions } from 'typeorm';
import { RelationMetadata } from 'typeorm/metadata/RelationMetadata';
export declare class TypeOrmCrudService<T> extends CrudService<T> {
    protected repo: Repository<T>;
    protected dbName: ConnectionOptions['type'];
    protected entityColumns: string[];
    protected entityPrimaryColumns: string[];
    protected entityColumnsHash: ObjectLiteral;
    protected entityRelationsHash: ObjectLiteral;
    protected sqlInjectionRegEx: RegExp[];
    constructor(repo: Repository<T>);
    readonly findOne: Repository<T>['findOne'];
    readonly find: Repository<T>['find'];
    readonly count: Repository<T>['count'];
    protected readonly entityType: ClassType<T>;
    protected readonly alias: string;
    getMany(req: CrudRequest): Promise<GetManyDefaultResponse<T> | T[]>;
    getOne(req: CrudRequest): Promise<T>;
    createOne(req: CrudRequest, dto: DeepPartial<T>): Promise<T>;
    createMany(req: CrudRequest, dto: CreateManyDto<DeepPartial<T>>): Promise<T[]>;
    updateOne(req: CrudRequest, dto: DeepPartial<T>): Promise<T>;
    replaceOne(req: CrudRequest, dto: DeepPartial<T>): Promise<T>;
    deleteOne(req: CrudRequest): Promise<void | T>;
    getParamFilters(parsed: CrudRequest['parsed']): ObjectLiteral;
    decidePagination(parsed: ParsedRequestParams, options: CrudRequestOptions): boolean;
    createBuilder(parsed: ParsedRequestParams, options: CrudRequestOptions, many?: boolean): Promise<SelectQueryBuilder<T>>;
    protected doGetMany(builder: SelectQueryBuilder<T>, query: ParsedRequestParams, options: CrudRequestOptions): Promise<GetManyDefaultResponse<T> | T[]>;
    protected onInitMapEntityColumns(): void;
    protected onInitMapRelations(): void;
    protected getOneOrFail(req: CrudRequest, shallow?: boolean): Promise<T>;
    protected prepareEntityBeforeSave(dto: DeepPartial<T>, parsed: CrudRequest['parsed']): T;
    protected getAllowedColumns(columns: string[], options: QueryOptions): string[];
    protected getRelationMetadata(field: string): RelationMetadata & {
        nestedRelation?: string;
    };
    protected setJoin(cond: QueryJoin, joinOptions: JoinOptions, builder: SelectQueryBuilder<T>): boolean;
    protected setAndWhere(cond: QueryFilter, i: any, builder: SelectQueryBuilder<T> | WhereExpression): void;
    protected setOrWhere(cond: QueryFilter, i: any, builder: SelectQueryBuilder<T> | WhereExpression): void;
    protected setSearchCondition(builder: SelectQueryBuilder<T>, search: SCondition, condition?: SConditionKey): void;
    protected builderAddBrackets(builder: SelectQueryBuilder<T>, condition: SConditionKey, brackets: Brackets): void;
    protected builderSetWhere(builder: SelectQueryBuilder<T>, condition: SConditionKey, field: string, value: any, operator?: ComparisonOperator): void;
    protected setSearchFieldObjectCondition(builder: SelectQueryBuilder<T>, condition: SConditionKey, field: string, object: any): void;
    protected getSelect(query: ParsedRequestParams, options: QueryOptions): string[];
    protected getSort(query: ParsedRequestParams, options: QueryOptions): ObjectLiteral;
    protected getFieldWithAlias(field: string, sort?: boolean): string;
    protected mapSort(sort: QuerySort[]): ObjectLiteral;
    protected mapOperatorsToQuery(cond: QueryFilter, param: any): {
        str: string;
        params: ObjectLiteral;
    };
    private checkFilterIsArray;
    private checkSqlInjection;
}
